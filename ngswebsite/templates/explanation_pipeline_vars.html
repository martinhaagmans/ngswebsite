<!-- extend from base layout -->
{% extends "base.html" %}

{% block content %}
<h1>PIPELINE</h1>
<hr>
<p>De AMC diagnostische pipeline voor de analyse van sequence capture data
  alignt reads tegen het referentiegenoom, callt de varianten en verzamelt
  informatie over de kwaliteit van de data. De varianten worden op kwaliteit
  gefilterd en in een VCF geraporteerd zodat ze in Cartagenia verder
  geanalyseerd kunnen worden. De verzamelde informatie wordt per patient in
  een excelfile gerapporteerd.<br>
  <br>
  Als alle patiÃ«nten uit een serie de pipeline succesvol hebben
  doorlopen dan worden er nog een aantal scripts gerund om informatie te
  verzamelen en te presenteren.
</p>

<hr>
<h2>Voorbereiding</h2>
<p>De pipeline begint met per sample verzamelen van targetfiles voor de verschillende
    onderdelen in de pipeline en het maken van een todo lijst van analyses. Welke
    targetfiles bij welke stappen horen staat 
    <a href="{{ url_for('database_explained') }}">hier</a> uitgelgegd. 
</p>

<hr>
<h2>Read alignment en markeren van duplicaten</h2>
<p>De reads worden vergeleken met de referentie en de aligner (BWA-MEM) kiest
  de best passende locatie in het genoom. Wanneer alle reads aan de beurt zijn
  geweest worden de reads die dezelfde start en eindlocatie hebben als duplicaat
  gemarkeerd. Dit zijn door PCR gedupliceerde moleculen en deze bevatten
  dezelfde informatie, zodat er maar 1 telt als coverage.
</p>
<pre><code class="snakemake">
rule mapreads:
    input:
        "reads/{sample}.R1.fastq.gz",
        "reads/{sample}.R2.fastq.gz"
    output:
        "alignments/{sample}.sorted.bam"
    params:
        rg = "@RG\\tID:{sample}\\tLB:{sample}\\tPL:ILLUMINA\\tPU:{sample}\\tSM:{sample}"
    shell:
        """(bwa mem  -R '{params.rg}' -t 1 -M {REF} {input} |\
        samtools view -Shu - |\
        samtools sort -T {wildcards.sample}.tmp -O bam - &gt; {output}) 2&gt; {log}
        """

rule markduplicates:
    input:
        rules.mapreads.output
    output:
        bam = "output/{sample}.DM.bam",
        metrics = temp("picardmetrics/{sample}.dupmark.txt")
    log:
        "logfiles/{sample}.MarkDuplicates.log"
    message:
        "Marking duplicates with picard"
    shell:
        """{PICARD} MarkDuplicates  I={input} O={output.bam}  \
        M={output.metrics} REMOVE_DUPLICATES=FALSE CREATE_INDEX=true > {log}  2>&1
        """
</code></pre>
<hr>

<h2>Base score recalibratie</h2>
<p>De MiSeq geeft elke base een kwaliteitsscore. Om deze scores onderling
  beter te kunnen vergelijken worden deze gerecalibreerd met GATK. Dit heeft
  als bijkomend voordeel dat het spectrum van scores breder wordt, waardoor
  er gevoeliger gefilterd kan worden.
</p>
<pre><code class="snakemake">
    rule recalibrate:
    input:
        expand("output/{sample}.DM.bam", sample=samples)
    output:
        "reads/bqsr.grp"
    log:
        "logfiles/Recal.log"
    message:
        "Recalibrating quality scores with GATK"
    threads:
        10
    run:
        create_recalinput_file(samples)
        shell("""{JAVA} -Xmx10g -jar {GATK} -R {REF} -T BaseRecalibrator -knownSites {DBSNP} \
        -I recalinput.list -o {output} -nct {threads} > {log} 2>&1
        """)

</code></pre>
<hr>

<h2>Varianten callen en filteren</h2>
<p>De varianten worden gecalld met de Haplotypecaller van GATK. Deze doet in
  gebieden met een afwijking tov de referentie een lokale de-novo reassembly
  van de reads en verdeelt de reads over verschillende haplotypes. Uit de twee
  haplotypes met het meeste bewijs worden de varianten gecalld.
</p>
<pre><code class="snakemake">
    rule callvariants:
        input:
            bamfile = rules.markduplicates.output.bam,
            table = rules.recalibrate.output
        output:
            temp("gatkfiles/{sample}.raw.vcf"),
            temp("gatkfiles/{sample}.raw.vcf.idx")
        message:
            "Calling variants with GATK's HaplotypeCaller"
        log:
            "logfiles/{sample}.HaplotypeCaller.log"
        run:
            target = input_dict[wildcards.sample]['varcal']
            shell("""{JAVA} -jar {GATK} -R {REF} -T HaplotypeCaller \
            -I {input.bamfile} -o {output[0]} -L {target} -ip 500 \
            -pairHMM VECTOR_LOGLESS_CACHING -BQSR {input.table}  > {log} 2>&1
            """)

    rule filtervariants:
        input:
            vcf = rules.callvariants.output[0],
            index = rules.callvariants.output[1]
        output:
            "output/{sample}.filtered.vcf"
        log:
            "logfiles/{sample}.VariantFiltration.log"
        message:
            "Annotating variants with GATK's QC annotations"
        shell:
            """{JAVA} -jar {GATK} -R {REF} -T VariantFiltration \
            -V {input.vcf} -o {output} \
            --clusterWindowSize 20 --clusterSize 6 \
            --filterExpression "DP < 30 " --filterName "LowCoverage" \
            --filterExpression "QUAL < 50.0 " --filterName "LowQual" \
            --filterExpression "QD < 4.0 " --filterName "QD" \
            --filterExpression "SOR > 10.0 " --filterName "SOR" > {log} 2>&1
            """
 
</code>
</code></pre>
<table>
    <colgroup>
        <col width="20%" />
        <col width="7%" />
        <col width="74%" />
    </colgroup>
    <thead valign="bottom">
        <tr class="row-odd">
            <th class="head">FilterName</th>
            <th class="head">Waarde</th>
            <th class="head">Betekenis</th>
        </tr>
    </thead>
    <tbody valign="top">
        <tr class="row-even">
            <td>LowCoverage</td>
            <td>&lt; 30</td>
            <td>Minder dan 30x verticale coverage</td>
        </tr>
        <tr class="row-odd">
            <td>LowQual</td>
            <td>&lt; 50</td>
            <td>Kwaliteit te laag</td>
        </tr>
        <tr class="row-even">
            <td>HARD_TO_VALIDATE</td>
            <td>&gt; 0.6</td>
            <td>Aligment niet betrouwbaar genoeg</td>
        </tr>
        <tr class="row-odd">
            <td>FSFilter</td>
            <td>&gt; 200</td>
            <td>Strandverdeling variant significant anders dan referentie</td>
        </tr>
        <tr class="row-even">
            <td>QD</td>
            <td>&lt; 0.1</td>
            <td>Kwaliteit gerelateerd aan coverage te laag</td>
        </tr>
        </tbody>
</table>

{% endblock content %}
